<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scanner (simples) — Limitador de largura ajustável</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root { color-scheme: dark; }
    body { padding: 16px; background:#0b1020; color:#e6e9f2; }
    .card { background:#11172b; border:1px solid #1c2744; }
    video { width: 100%; height: auto; background: #000; border-radius: 12px; }
    canvas { width: 100%; max-width: 400px; border:1px dashed #233059; border-radius:8px; }
    .hint { color:#aab3c9; }
    .badge-soft { background:#1a2446; color:#a7b3d6; border:1px solid #27335b; }
    .ctrl { display:flex; align-items:center; gap:.5rem; }
    input[type="range"] { width: 180px; }
  </style>
</head>
<body>
  <div class="container py-3">
    <div class="card shadow">
      <div class="card-body">
        <h1 class="h5 mb-2">Scanner (simples) — com limitador de câmera</h1>
        <p class="hint mb-2">
          Versão direta: pede câmera traseira, <b>limita a largura de processamento</b> e tenta de novo a cada frame. Ideal para leituras rápidas de EAN/Code128.
          Requer <b>HTTPS</b> para a câmera embutida. Sem HTTPS, use o botão de foto.
        </p>

        <div class="d-flex flex-wrap gap-2 mb-3">
          <button class="btn btn-primary" id="btnStart">Iniciar</button>
          <button class="btn btn-outline-secondary" id="btnStop" disabled>Parar</button>
          <button class="btn btn-outline-secondary" id="btnTorch" disabled>Lanterna</button>
          <label class="btn btn-outline-secondary mb-0">
            Foto (fallback) <input id="fileInput" type="file" accept="image/*" capture="environment" hidden>
          </label>
          <div class="ctrl ms-auto">
            <label for="procW" class="form-check-label">Largura:</label>
            <input type="range" id="procW" min="480" max="1280" step="80" value="800">
            <span id="procWVal" class="badge badge-soft">800 px</span>
          </div>
        </div>

        <div class="row g-3">
          <div class="col-12 col-md-7">
            <video id="preview" playsinline muted></video>
            <div class="d-flex flex-wrap gap-2 mt-2">
              <span class="badge badge-soft" id="badgeCam">Câmera: —</span>
              <span class="badge badge-soft" id="badgeRes">Resolução: —</span>
              <span class="badge badge-soft" id="badgeCtx">secureContext: —</span>
            </div>
          </div>
          <div class="col-12 col-md-5">
            <div class="mb-2">
              <label class="form-label">Último código</label>
              <input id="ultimoCodigo" class="form-control" readonly placeholder="—">
            </div>
            <div class="mb-2">
              <label class="form-label">Prévia processada</label><br>
              <canvas id="frame" width="800" height="450"></canvas>
              <div class="hint mt-1">A imagem do vídeo é redimensionada para a <b>largura selecionada</b>, preservando proporção.</div>
            </div>
            <div class="mb-2">
              <label class="form-label">Leituras</label>
              <div class="list-group" id="listaCodigos" style="max-height:40vh;overflow:auto;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ZXing -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.4"></script>

  <script>
    // ===== Config =====
    const FORMATS = [
      ZXing.BarcodeFormat.EAN_13, ZXing.BarcodeFormat.EAN_8,
      ZXing.BarcodeFormat.UPC_A, ZXing.BarcodeFormat.UPC_E,
      ZXing.BarcodeFormat.CODE_128, ZXing.BarcodeFormat.ITF,
      ZXing.BarcodeFormat.CODE_39
    ];
    const DUP_MS = 1200;

    // ===== Estado =====
    let video = document.getElementById('preview');
    let canvas = document.getElementById('frame');
    let ctx = canvas.getContext('2d');
    let stream = null, track = null;
    let lastCode = null, lastT = 0;
    let torchOn = false;
    let PROC_WIDTH = 800;

    const $ = s => document.querySelector(s);
    const reader = new ZXing.BrowserMultiFormatReader(new Map([[ZXing.DecodeHintType.POSSIBLE_FORMATS, FORMATS]]));

    function beep() {
      try{
        const a = new (window.AudioContext||window.webkitAudioContext)();
        const o = a.createOscillator(), g = a.createGain();
        o.type='square'; o.frequency.value=880; o.connect(g); g.connect(a.destination);
        g.gain.setValueAtTime(0.0001, a.currentTime);
        g.gain.exponentialRampToValueAtTime(0.1, a.currentTime+0.01);
        o.start(); setTimeout(()=>{o.stop(); a.close();},120);
      }catch{}
      if(navigator.vibrate) navigator.vibrate(60);
    }
    const avoidDup = (t)=> (t===lastCode && (Date.now()-lastT)<DUP_MS) ? true : (lastCode=t,lastT=Date.now(),false);
    function addLog(text, fmt){
      const item = document.createElement('div');
      item.className = 'list-group-item list-group-item-action';
      item.textContent = `[${new Date().toLocaleTimeString()}] ${text} (${fmt})`;
      $('#listaCodigos').prepend(item);
    }

    function updateResBadge(){
      const vw = video.videoWidth, vh = video.videoHeight;
      document.getElementById('badgeRes').textContent = 'Resolução: ' + (vw ? `${vw}×${vh}` : '—');
    }

    async function start(){
      if(!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || !window.isSecureContext){
        alert('Precisa de HTTPS para câmera embutida. Abra via GitHub Pages.');
        return;
      }
      try {
        const constraints = {
          video: {
            facingMode: { ideal: 'environment' },
            width: { ideal: 1920 }, height: { ideal: 1080 }, // pedimos alta; limitamos no processamento
            frameRate: { ideal: 30, max: 60 }
          },
          audio: false
        };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        track = stream.getVideoTracks()[0];
        // Torch disponível?
        document.getElementById('btnTorch').disabled = !('torch' in (track?.getCapabilities?.() || {}));
        await video.play();
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStop').disabled = false;
        document.getElementById('badgeCam').textContent = 'Câmera: ' + (track.label || '—');
        document.getElementById('badgeCtx').textContent = 'secureContext: sim';
        updateResBadge();
        scanLoop();
      } catch (e) {
        console.error(e);
        alert('Não consegui iniciar a câmera. Verifique permissões/HTTPS.');
      }
    }

    function stop(){
      try{ reader.reset(); }catch{}
      try{ stream?.getTracks().forEach(t=>t.stop()); }catch{}
      stream=null; track=null;
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      document.getElementById('btnTorch').disabled = true;
    }

    async function scanLoop(){
      if(!stream) return;
      updateResBadge();

      const vw = video.videoWidth || 1920;
      const vh = video.videoHeight || 1080;
      const scale = Math.min(1, PROC_WIDTH / vw);
      canvas.width  = Math.round(vw * scale);
      canvas.height = Math.round(vh * scale);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      try{
        const luminance = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
        const binarizer = new ZXing.GlobalHistogramBinarizer(luminance);
        const bitmap = new ZXing.BinaryBitmap(binarizer);
        const result = reader.decodeBitmap(bitmap);
        if(result && result.getText){
          const text = result.getText();
          const format = ZXing.BarcodeFormat[result.getBarcodeFormat?.()] || '—';
          if(!avoidDup(text)){
            beep();
            document.getElementById('ultimoCodigo').value = text;
            addLog(text, format);
          }
        }
      }catch(e){ /* sem leitura neste frame é normal */ }

      requestAnimationFrame(scanLoop);
    }

    async function toggleTorch(){
      if(!track) return;
      const caps = track.getCapabilities?.() || {};
      if(!caps.torch) return;
      let on = !('torchOn' in toggleTorch) || !toggleTorch.torchOn;
      await track.applyConstraints({ advanced: [{ torch: on }] });
      toggleTorch.torchOn = on;
      document.getElementById('btnTorch').textContent = on ? 'Lanterna (ON)' : 'Lanterna';
    }

    // Fallback: decodificar de foto
    async function decodeFile(file){
      const img = await new Promise(res=>{
        const i = new Image(); i.onload=()=>res(i); i.src=URL.createObjectURL(file);
      });
      const scale = Math.min(1, PROC_WIDTH / img.naturalWidth);
      canvas.width  = Math.round(img.naturalWidth * scale);
      canvas.height = Math.round(img.naturalHeight * scale);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      try{
        const luminance = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
        const binarizer = new ZXing.GlobalHistogramBinarizer(luminance);
        const bitmap = new ZXing.BinaryBitmap(binarizer);
        const result = reader.decodeBitmap(bitmap);
        if(result && result.getText){
          const text = result.getText();
          const format = ZXing.BarcodeFormat[result.getBarcodeFormat?.()] || '—';
          beep();
          document.getElementById('ultimoCodigo').value = text;
          addLog(text, format);
        } else {
          alert('Nenhum código detectado nesta imagem.');
        }
      }catch(e){
        alert('Falha ao detectar código nesta imagem.');
      }
    }

    // Eventos
    document.getElementById('btnStart').addEventListener('click', start);
    document.getElementById('btnStop').addEventListener('click', stop);
    document.getElementById('btnTorch').addEventListener('click', toggleTorch);
    document.getElementById('fileInput').addEventListener('change', (e)=>{
      const f = e.target.files?.[0]; if(f) decodeFile(f);
    });

    const range = document.getElementById('procW');
    const label = document.getElementById('procWVal');
    function updateProcWidth(val){
      PROC_WIDTH = Number(val)||800;
      label.textContent = PROC_WIDTH + ' px';
      // atualiza canvas imediatamente com nova largura (scanLoop aplica no próximo frame)
    }
    range.addEventListener('input', (e)=> updateProcWidth(e.target.value));
    updateProcWidth(range.value);

    // Contexto
    document.getElementById('badgeCtx').textContent = 'secureContext: ' + (window.isSecureContext ? 'sim':'não');
  </script>
</body>
</html>