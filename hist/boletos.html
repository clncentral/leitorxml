<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Captura de Linhas Digitáveis (apenas códigos únicos)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root { --bg:#0b0d12; --card:#141824; --text:#e8ecf1; --muted:#9aa4b2; --accent:#3aa3ff; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:900px;margin:36px auto;padding:20px}
  .card{background:var(--card);border:1px solid #22283a;border-radius:14px;padding:20px}
  h1{margin:0 0 14px;font-size:18px}
  label{display:block;margin:.6rem 0 .25rem;color:var(--muted)}
  input[type="url"],input[type="password"],textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2b3350;background:#0f1320;color:var(--text)}
  textarea{min-height:120px;resize:vertical}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .btn{background:var(--accent);border:none;color:#001025;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn-outline{background:transparent;color:#fff;border:1px solid #2b3350}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;font-size:12px;background:#0f1320;border:1px solid #2b3350;color:#cfe1ff}
  #out{margin-top:12px;padding:12px;border:1px solid #2b3350;background:#0f1320;border-radius:10px;white-space:pre-wrap;min-height:140px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

  /* --- Tabela adicionada --- */
  table{width:100%;border-collapse:separate;border-spacing:0;margin-top:18px}
  th,td{padding:10px 12px;border-bottom:1px solid #22283a}
  thead th{position:sticky;top:0;background:#151a27;border-bottom:1px solid #2a3248;z-index:1}
  tbody tr:nth-child(even){background:#0f1320}
  .right{text-align:right}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Capturar códigos (apenas saída, única por linha)</h1>

    <div class="row">
      <div style="flex:1 1 360px">
        <label for="pdfUrl">URL do PDF</label>
        <input id="pdfUrl" type="url" placeholder="https://.../boleto.pdf">
      </div>
      <div style="display:flex;align-items:flex-end;gap:8px">
        <button id="btnUrl" class="btn btn-outline" type="button">Ler URL</button>
        <input id="pdfFile" type="file" accept="application/pdf" style="display:none">
        <button id="btnFilePick" class="btn btn-outline" type="button">Ler arquivo…</button>
        <button id="btnScan" class="btn" type="button">Procurar no texto</button>
      </div>
    </div>

    <div id="pwBox" class="row" style="display:none">
      <div style="flex:1 1 240px">
        <label for="pdfPassword">Senha do PDF (se houver)</label>
        <input id="pdfPassword" type="password" placeholder="Digite a senha e clique em Tentar senha">
      </div>
      <button id="btnTryPw" class="btn" type="button">Tentar senha</button>
      <span class="badge">Tentativas auto: 28021, 05789</span>
    </div>

    <label for="src">Texto (opcional, para colar manualmente)</label>
    <textarea id="src" class="mono" placeholder="Cole aqui qualquer trecho; clicando em 'Procurar no texto' a saída abaixo mostrará somente os códigos únicos"></textarea>

    <div class="row">
      <span id="status" class="badge">Aguardando…</span>
      <span id="pages" class="badge">0 págs</span>
      <button id="limpar" class="btn" type="button">Limpar tudo</button>
    </div>

    <pre id="out" class="mono" aria-label="Saída: apenas códigos únicos" style="display:none"></pre>

    <!-- TABELA (adicionada) -->
    <table id="tabela" style="display:none">
      <thead>
        <tr>
          <th style="width:90px">Parcela</th>
          <th>Chave</th>
          <th style="width:160px">Vencimento</th>
          <th style="width:160px" class="right">Valor</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

<!-- pdf.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';</script>

<!-- SEU SCRIPT ORIGINAL (inalterado) -->
<script>
(function(){
  const $ = s => document.querySelector(s);
  const elUrl = $('#pdfUrl'), elFilePick = $('#btnFilePick'), elFile = document.getElementById('pdfFile');
  const elSrc = $('#src'), elOut = $('#out'), elStatus = $('#status'), elPages = $('#pages');
  const btnUrl = $('#btnUrl'), btnScan = $('#btnScan'), btnTryPw = $('#btnTryPw'), elPw = $('#pdfPassword'), pwBox = $('#pwBox');
  const btnClear = $('#limpar');

  function setStatus(t, cls=''){ elStatus.textContent=t; elStatus.className='badge ' + (cls||''); }

  // ---------- Normalizações ----------
  function normalizeForKey(s){
    if(!s) return '';
    return s
      .replace(/[\u00A0]/g, ' ')
      .replace(/[\u2010-\u2015\u2212\u2043\uFE58\uFE63\uFF0D]/g,'-')
      .replace(/\s+/g,' ')
      .trim();
  }

  // ---------- Padrões (3 formatos) ----------
  const RE_COBR47 = /\b\d{5}\.\d{5}\s+\d{5}\.\d{6}\s+\d{5}\.\d{6}\s+\d\s+\d{14}\b/g;
  const RE_A48_11DV = /\b\d{11}\s*-\s*\d\s+\d{11}\s*-\s*\d\s+\d{11}\s*-\s*\d\s+\d{11}\s*-\s*\d\b/g;
  const RE_COBR43 = /\b\d{5}\.\d{5}\s+\d{5}\.\d{6}\s+\d{5}\.\d{6}\s+\d\s+\d{10}\b/g;

  function captureUniqueCodes(rawText){
    const T = (rawText||'').replace(/\u00A0/g,' ');
    const ordered = [];
    const seen = new Set();

    function pushMatches(re, text){
      for(const m of text.matchAll(re)){
        const captured = m[0];
        const key = normalizeForKey(captured);
        if (!seen.has(key)){
          seen.add(key);
          ordered.push(key);
        }
      }
    }

    const TnormHyphens = normalizeForKey(T);

    pushMatches(RE_COBR47, T);
    pushMatches(RE_A48_11DV, TnormHyphens);
    pushMatches(RE_COBR43, T);

    return ordered;
  }

  async function extractTextFromPdf(pdf){
    let text = '';
    for(let p=1;p<=pdf.numPages;p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      text += content.items.map(i=>i.str).join(' ') + '\n';
    }
    return { text, numPages: pdf.numPages };
  }

  const SENHAS_PADRAO = ['28021','05789','2802','0578','280216','057893'];

  async function openPdfWithPasswords(source, kind, extraPassword){
    const tries=[...SENHAS_PADRAO];
    if(extraPassword){
      const e=(extraPassword||'').trim();
      if(e && !tries.includes(e)) tries.push(e);
    }
    for(const pw of tries){
      try{
        const arg = (kind==='url') ? {url:source, password:pw} : {data:source, password:pw};
        const pdf = await pdfjsLib.getDocument(arg).promise;
        setStatus(pw?'PDF aberto com senha.':'PDF aberto.','');
        pwBox.style.display='none';
        return pdf;
      }catch(e){
        if(e && e.name==='PasswordException'){ if(e.code===1||e.code===2) continue; }
        throw e;
      }
    }
    pwBox.style.display='flex';
    setStatus('PDF protegido: informe a senha.','');
    return null;
  }

  async function openPdfManualPassword(source, kind, password){
    const pw=(password||'').trim();
    if(!pw){ setStatus('Digite a senha.',''); return null; }
    try{
      const arg=(kind==='url')?{url:source, password:pw}:{data:source, password:pw};
      const pdf=await pdfjsLib.getDocument(arg).promise;
      setStatus('PDF aberto com a senha informada.',''); pwBox.style.display='none'; return pdf;
    }catch(e){
      if(e && e.name==='PasswordException'){ setStatus('Senha incorreta.',''); return null; }
      throw e;
    }
  }

  btnUrl.addEventListener('click', async ()=>{
    const url = elUrl.value.trim();
    if(!url){ setStatus('Informe a URL do PDF.'); return; }
    try{
      setStatus('Lendo PDF da URL…');
      let pdf = await openPdfWithPasswords(url,'url', null);
      if (!pdf){
        btnTryPw.onclick = async ()=>{
          const pdf2 = await openPdfManualPassword(url,'url', elPw.value);
          if (pdf2){
            const {text, numPages} = await extractTextFromPdf(pdf2);
            elPages.textContent = `${numPages} págs`;
            const codes = captureUniqueCodes(text);
            elOut.textContent = codes.join('\n'); // APENAS códigos
            setStatus(`Capturados: ${codes.length}`);
          }
        };
        return;
      }
      const {text, numPages} = await extractTextFromPdf(pdf);
      elPages.textContent = `${numPages} págs`;
      const codes = captureUniqueCodes(text);
      elOut.textContent = codes.join('\n');
      setStatus(`Capturados: ${codes.length}`);
    }catch(e){
      console.error(e);
      setStatus('Erro ao ler URL: '+e.message);
    }
  });

  elFilePick.addEventListener('click', ()=> elFile.click());

  elFile.addEventListener('change', async ()=>{
    const file = elFile.files && elFile.files[0];
    if(!file){ setStatus('Escolha um PDF.'); return; }
    try{
      setStatus('Abrindo PDF local…');
      const buf = await file.arrayBuffer();
      let pdf = await openPdfWithPasswords(buf,'data', null);
      if (!pdf){
        btnTryPw.onclick = async ()=>{
          const pdf2 = await openPdfManualPassword(buf,'data', elPw.value);
          if (pdf2){
            const {text, numPages} = await extractTextFromPdf(pdf2);
            elPages.textContent = `${numPages} págs`;
            const codes = captureUniqueCodes(text);
            elOut.textContent = codes.join('\n');
            setStatus(`Capturados: ${codes.length}`);
          }
        };
        return;
      }
      const {text, numPages} = await extractTextFromPdf(pdf);
      elPages.textContent = `${numPages} págs`;
      const codes = captureUniqueCodes(text);
      elOut.textContent = codes.join('\n');
      setStatus(`Capturados: ${codes.length}`);
    }catch(e){
      console.error(e);
      setStatus('Erro ao ler arquivo: '+e.message);
    }
  });

  btnScan.addEventListener('click', ()=>{
    const t = elSrc.value;
    if(!t.trim()){ setStatus('Cole algum texto para procurar.'); return; }
    const codes = captureUniqueCodes(t);
    elOut.textContent = codes.join('\n');
    setStatus(`Capturados: ${codes.length}`);
  });

  btnTryPw.addEventListener('click', ()=>{});

  btnClear.addEventListener('click', ()=>{
    elUrl.value=''; elSrc.value=''; elOut.textContent=''; elPages.textContent='0 págs'; elPw.value='';
    setStatus('Aguardando…'); pwBox.style.display='none'; if(elFile) elFile.value='';
  });
})();
</script>

<!-- SCRIPT EXTRA: monta a tabela a partir do #out (sem alterar nada do seu JS) -->
<script>
(function(){
  const elOut = document.getElementById('out');
  const elTable = document.getElementById('tabela');
  const elTbody = document.getElementById('tbody');

  // Utilitários para vencimento/valor
  const BASE_OLD = new Date(Date.UTC(1997, 9, 7));   // 07/10/1997
  const BASE_NEW = new Date(Date.UTC(2025, 1, 22));  // 22/02/2025
  const toBRL = cents => (cents==null || isNaN(cents)) ? '—' : (cents/100).toLocaleString('pt-BR',{style:'currency',currency:'BRL'});
  function addDaysUTC(base, days){ const d=new Date(base.getTime()); d.setUTCDate(d.getUTCDate()+days); return d; }
  function fmtDateUTC(d){ if(!d) return '-'; const y=d.getUTCFullYear(), m=String(d.getUTCMonth()+1).padStart(2,'0'), day=String(d.getUTCDate()).padStart(2,'0'); return `${day}/${m}/${y}`; }
  const digitsOnly = s => (s||'').replace(/\D+/g,'');

  // Arrecadação: converte 48 dígitos (11+DV ×4) para barcode 44 (tirando cada 12º dígito)
  function d48_to_bc44(d48){
    const b1=d48.slice(0,11), b2=d48.slice(12,23), b3=d48.slice(24,35), b4=d48.slice(36,47);
    return b1+b2+b3+b4;
  }
  function parseArrecFromD48(d48){
    if(!/^\d{48}$/.test(d48)) return null;
    const bc44 = d48_to_bc44(d48);
    if (bc44[0] !== '8') return null;
    const tipoValor = bc44[2]; // 6 efetivo, 7 referência
    let valorCents = null;
    if (tipoValor === '6'){
      const vs = bc44.slice(4,15);
      if (/^\d{11}$/.test(vs)) valorCents = parseInt(vs,10);
    }
    return { vencStr: '-', valorCents };
  }

  function calcVencCobranca(fator){
    if (!Number.isInteger(fator)) return null;
    if (fator===0) return null;                  // sem vencimento
    if (fator>=1000) return addDaysUTC(BASE_NEW, fator-1000);
    return addDaysUTC(BASE_OLD, fator);
  }

  // Interpreta UMA linha do #out (que já veio nos 3 formatos que você captura)
  function parseLine(line){
    const d = digitsOnly(line);
    // 47 – cobrança (com vencimento + valor)
    if (d.length === 47){
      const fator = parseInt(d.slice(33,37),10);     // 4 dígitos
      const valorCents = parseInt(d.slice(37,47),10);// 10 dígitos (centavos)
      const venc = calcVencCobranca(Number.isNaN(fator)?null:fator);
      return { chave: line.trim(), vencStr: venc ? fmtDateUTC(venc) : '-', valorCents };
    }
    // 43 – cobrança “sem vencimento”
    if (d.length === 43){
      const valor10 = d.slice(-10);
      const valorCents = /^\d{10}$/.test(valor10) ? parseInt(valor10,10) : null;
      return { chave: line.trim(), vencStr: '-', valorCents };
    }
    // 48 – arrecadação (11+DV com hífen, que você captura)
    if (d.length === 48 && d.startsWith('8')){
      const ar = parseArrecFromD48(d);
      if (ar) return { chave: line.trim(), vencStr: '-', valorCents: ar.valorCents };
    }
    // desconhecido: ignora (não entra na tabela)
    return null;
  }

  function buildTableFromOut(){
    const raw = elOut.textContent || '';
    const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);

    elTbody.innerHTML = '';
    if (!lines.length){ elTable.style.display='none'; return; }

    const rows = [];
    for (const l of lines){
      const info = parseLine(l);
      if (info) rows.push(info);
    }

    if (!rows.length){ elTable.style.display='none'; return; }
    elTable.style.display='table';

    rows.forEach((r, i)=>{
      const tr = document.createElement('tr');

      const td1 = document.createElement('td'); td1.textContent = i+1; td1.className='mono';
      const td2 = document.createElement('td'); td2.textContent = r.chave; td2.className='mono';
      const td3 = document.createElement('td'); td3.textContent = r.vencStr || '-';
      const td4 = document.createElement('td'); td4.textContent = toBRL(r.valorCents); td4.className='right mono';

      tr.append(td1, td2, td3, td4);
      elTbody.appendChild(tr);
    });
  }

  // Observa qualquer mudança no #out e reconstrói a tabela
  const obs = new MutationObserver(buildTableFromOut);
  obs.observe(elOut, { childList: true, characterData: true, subtree: true });

  // Se já existir conteúdo (ex.: colado manualmente e clicou “Procurar no texto” antes de carregar este script)
  buildTableFromOut();
})();
</script>
</body>
</html>
