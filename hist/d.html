<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scanner ao vivo — Alta resolução + ROI + Zoom (ZXing)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root { color-scheme: dark; }
    body { padding: 16px; background: #0b1020; color: #e6e9f2; }
    .card { background: #11172b; border: 1px solid #1c2744; }
    .hint { color:#aab3c9; }
    video#preview { width:100%; height:auto; background:#000; border-radius:12px; }
    canvas#frame { width:100%; max-width:400px; border:1px dashed #233059; border-radius:8px; }
    .overlay {
      position:absolute; inset:0; pointer-events:none;
    }
    .roi {
      position:absolute; border:2px solid #36d399; border-radius:12px;
      left:50%; top:50%; transform:translate(-50%,-50%);
      width:80%; height:40%; /* área central */
      box-shadow: 0 0 0 9999px rgba(0,0,0,.35); /* vinheta */
    }
    .badge-soft { background:#1a2446; color:#a7b3d6; border:1px solid #27335b; }
    .ctrl { display:flex; align-items:center; gap:.5rem; }
    input[type="range"] { width: 160px; }
  </style>
</head>
<body>
  <div class="container py-3">
    <div class="card shadow">
      <div class="card-body">
        <h1 class="h5 mb-2">Scanner ao vivo — Alta resolução + ROI + Zoom</h1>
        <p class="hint mb-3">
          Para melhor leitura: foco contínuo, resolução alta, região de interesse (ROI) e zoom quando disponível. Requer <b>HTTPS</b>.
        </p>

        <div class="d-flex flex-wrap gap-2 mb-3">
          <button class="btn btn-primary" id="btnStart">Iniciar</button>
          <button class="btn btn-outline-secondary" id="btnStop" disabled>Parar</button>
          <button class="btn btn-outline-secondary" id="btnTorch" disabled>Lanterna</button>
          <div class="ctrl">
            <label class="form-check-label me-1">Qualidade:</label>
            <select id="selQual" class="form-select form-select-sm" style="width:auto">
              <option value="hd" selected>HD (1920×1080)</option>
              <option value="sd">SD (1280×720)</option>
            </select>
          </div>
          <div class="ctrl">
            <label for="zoom" class="form-check-label">Zoom:</label>
            <input type="range" id="zoom" min="1" max="1" step="0.1" value="1" disabled />
            <span id="zoomVal" class="badge badge-soft">1×</span>
          </div>
          <div class="form-check ms-auto">
            <input class="form-check-input" type="checkbox" id="chkContinuo" checked>
            <label class="form-check-label" for="chkContinuo">Modo contínuo</label>
          </div>
        </div>

        <div class="row g-3">
          <div class="col-12 col-lg-7">
            <div style="position:relative">
              <video id="preview" playsinline muted></video>
              <div class="overlay">
                <div class="roi" id="roi"></div>
              </div>
            </div>
            <div class="d-flex flex-wrap gap-2 mt-2">
              <span class="badge badge-soft" id="badgeCam">Câmera: —</span>
              <span class="badge badge-soft" id="badgeRes">Resolução: —</span>
              <span class="badge badge-soft" id="badgeCtx">secureContext: —</span>
            </div>
          </div>
          <div class="col-12 col-lg-5">
            <div class="mb-2">
              <label class="form-label">Último código</label>
              <input id="ultimoCodigo" class="form-control" readonly placeholder="—">
            </div>
            <div class="mb-2">
              <label class="form-label">Prévia processada (ROI)</label><br>
              <canvas id="frame" width="1024" height="512"></canvas>
              <div class="hint mt-1">Apenas a área central é processada para maior precisão e velocidade.</div>
            </div>
            <div class="mb-2">
              <label class="form-label">Leituras</label>
              <div class="list-group" id="listaCodigos" style="max-height:40vh;overflow:auto;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ZXing -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.4"></script>

  <script>
    // ===== Config =====
    const FORMATS = [
      ZXing.BarcodeFormat.EAN_13, ZXing.BarcodeFormat.EAN_8,
      ZXing.BarcodeFormat.UPC_A, ZXing.BarcodeFormat.UPC_E,
      ZXing.BarcodeFormat.CODE_128, ZXing.BarcodeFormat.ITF,
      ZXing.BarcodeFormat.CODE_39
    ];
    const DUP_MS = 1200;
    const PROC_WIDTH_HD = 1280; // largura de processamento (canvas) em HD
    const PROC_WIDTH_SD = 960;  // em SD
    const ROI_W = 0.80; // 80% da largura
    const ROI_H = 0.40; // 40% da altura

    // ===== Estado =====
    let video = document.getElementById('preview');
    let canvas = document.getElementById('frame');
    let ctx = canvas.getContext('2d');
    let stream = null, track = null;
    let lastCode = null, lastT = 0;
    let torchOn = false;
    let quality = 'hd';
    let zoomCaps = null;

    const $ = s => document.querySelector(s);
    const reader = new ZXing.BrowserMultiFormatReader(new Map([[ZXing.DecodeHintType.POSSIBLE_FORMATS, FORMATS]]));

    function beep() {
      try{
        const a = new (window.AudioContext||window.webkitAudioContext)();
        const o = a.createOscillator(), g = a.createGain();
        o.type='square'; o.frequency.value=880; o.connect(g); g.connect(a.destination);
        g.gain.setValueAtTime(0.0001, a.currentTime);
        g.gain.exponentialRampToValueAtTime(0.1, a.currentTime+0.01);
        o.start(); setTimeout(()=>{o.stop(); a.close();},120);
      }catch{}
      if(navigator.vibrate) navigator.vibrate(60);
    }
    const avoidDup = (t)=> (t===lastCode && (Date.now()-lastT)<DUP_MS) ? true : (lastCode=t,lastT=Date.now(),false);
    function addLog(text, fmt){
      const item = document.createElement('div');
      item.className = 'list-group-item list-group-item-action';
      item.textContent = `[${new Date().toLocaleTimeString()}] ${text} (${fmt})`;
      $('#listaCodigos').prepend(item);
    }

    function procWidth(){ return quality==='hd' ? PROC_WIDTH_HD : PROC_WIDTH_SD; }

    async function start() {
      if(!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || !window.isSecureContext){
        alert('Precisa de HTTPS para câmera embutida. Abra via GitHub Pages.');
        return;
      }
      try{
        const wantHD = quality==='hd';
        const constraints = {
          video: {
            facingMode: { ideal: 'environment' },
            width:  { ideal: wantHD ? 1920 : 1280 },
            height: { ideal: wantHD ? 1080 : 720  },
            frameRate: { ideal: 30, max: 60 }
          },
          audio: false
        };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        track = stream.getVideoTracks()[0];

        // Tenta foco contínuo / auto (nem todos suportam)
        try {
          const caps = track.getCapabilities?.() || {};
          let adv = [];
          if(caps.focusMode && caps.focusMode.includes('continuous')) adv.push({ focusMode: 'continuous' });
          else if(caps.focusMode && caps.focusMode.includes('auto')) adv.push({ focusMode: 'auto' });
          if(adv.length) await track.applyConstraints({ advanced: adv });
          // Zoom
          if(caps.zoom){
            zoomCaps = caps.zoom;
            const z = document.getElementById('zoom');
            z.min = caps.zoom.min || 1;
            z.max = caps.zoom.max || 5;
            z.step = caps.zoom.step || 0.1;
            z.value = caps.zoom.min || 1;
            z.disabled = false;
            document.getElementById('zoomVal').textContent = (Number(z.value)).toFixed(1)+'×';
          } else {
            document.getElementById('zoom').disabled = true;
            document.getElementById('zoomVal').textContent = '—';
          }
          // Torch
          document.getElementById('btnTorch').disabled = !(caps.torch);
        } catch {}

        await video.play();
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStop').disabled = false;
        document.getElementById('badgeCtx').textContent = 'secureContext: sim';
        document.getElementById('badgeCam').textContent = 'Câmera: ' + (track.label || '—');
        updateResBadge();

        scanLoop();
      }catch(e){
        console.error(e);
        alert('Não consegui iniciar a câmera. Permissão/HTTPS/Compatibilidade.');
      }
    }

    function updateResBadge(){
      const vw = video.videoWidth, vh = video.videoHeight;
      document.getElementById('badgeRes').textContent = 'Resolução: ' + (vw ? `${vw}×${vh}` : '—');
    }

    function stop() {
      try{ reader.reset(); }catch{}
      try{ stream?.getTracks().forEach(t=>t.stop()); }catch{}
      stream=null; track=null;
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      document.getElementById('btnTorch').disabled = true;
      document.getElementById('zoom').disabled = true;
      document.getElementById('zoomVal').textContent = '—';
    }

    async function scanLoop(){
      if(!stream) return;
      updateResBadge();

      const vw = video.videoWidth || 1920, vh = video.videoHeight || 1080;
      // ROI central
      const rw = vw * ROI_W, rh = vh * ROI_H;
      const rx = (vw - rw) / 2, ry = (vh - rh) / 2;

      // Ajuste canvas mantendo proporção para largura de processamento
      const scale = Math.min(1, procWidth() / rw);
      canvas.width  = Math.round(rw * scale);
      canvas.height = Math.round(rh * scale);

      // Desenha apenas a ROI
      ctx.drawImage(video, rx, ry, rw, rh, 0, 0, canvas.width, canvas.height);

      try {
        const luminance = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
        const binarizer = new ZXing.GlobalHistogramBinarizer(luminance);
        const bitmap = new ZXing.BinaryBitmap(binarizer);
        const result = reader.decodeBitmap(bitmap);
        if(result && result.getText){
          const text = result.getText();
          const format = ZXing.BarcodeFormat[result.getBarcodeFormat?.()] || '—';
          if(!avoidDup(text)){
            beep();
            document.getElementById('ultimoCodigo').value = text;
            addLog(text, format);
            if(!document.getElementById('chkContinuo').checked) stop();
          }
        }
      } catch(e){ /* sem leitura no frame é normal */ }

      requestAnimationFrame(scanLoop);
    }

    async function toggleTorch(){
      if(!track) return;
      const caps = track.getCapabilities?.() || {};
      if(!caps.torch) return;
      torchOn = !torchOn;
      await track.applyConstraints({ advanced: [{ torch: torchOn }] });
      document.getElementById('btnTorch').textContent = torchOn ? 'Lanterna (ON)' : 'Lanterna';
    }

    async function onZoomChange(e){
      if(!track) return;
      const val = Number(e.target.value);
      try{
        await track.applyConstraints({ advanced: [{ zoom: val }] });
        document.getElementById('zoomVal').textContent = val.toFixed(1)+'×';
      }catch{}
    }

    // ===== Eventos =====
    document.getElementById('btnStart').addEventListener('click', start);
    document.getElementById('btnStop').addEventListener('click', stop);
    document.getElementById('btnTorch').addEventListener('click', toggleTorch);
    document.getElementById('zoom').addEventListener('input', onZoomChange);
    document.getElementById('selQual').addEventListener('change', (e)=>{
      quality = e.target.value; if(stream) { stop(); start(); }
    });

    // Info inicial
    document.getElementById('badgeCtx').textContent = 'secureContext: ' + (window.isSecureContext ? 'sim':'não');
  </script>
</body>
</html>